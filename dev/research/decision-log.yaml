# Research Decision Log
# SafeDownload Research → Decision Framework
# Version: 1.0.0

---
# How to Use This Document
#
# When a research area produces a decision:
# 1. Add a new entry to the `decisions` array below
# 2. Fill in all required fields
# 3. Update research_plan.yaml statistics
# 4. Update the relevant feature spec
# 5. Add to CHANGELOG.md if significant
#
# Decision Lifecycle:
#   PROPOSED → UNDER_REVIEW → APPROVED → IMPLEMENTED
#              ↓
#           REJECTED
---
metadata:
  version: "1.0.0"
  created: "2025-12-25"
  updated: "2025-12-28"
  total_decisions: 6
  decisions_pending: 6
  decisions_approved: 0
  decisions_implemented: 0

# Decision Criteria Weights
# Used when scoring options in research comparisons
criteria_weights:
  constitution_alignment: 25 # Does it align with project principles?
  performance: 20 # Does it meet performance gates?
  maintainability: 20 # Easy to maintain long-term?
  developer_experience: 15 # Good DX for contributors?
  community_support: 10 # Active community, documentation?
  dependency_footprint: 10 # Minimal dependencies per constitution?

# Decision Categories
categories:
  - name: "LIBRARY_SELECTION"
    description: "Choice of external library or framework"
    typical_criteria:
      - "License compatibility (BSD/MIT/Apache preferred)"
      - "Active maintenance (commits in last 6 months)"
      - "Documentation quality"
      - "Dependency count"
    required_fields:
      - "options_evaluated"
      - "selection_rationale"
      - "fallback_option"

  - name: "ARCHITECTURE_PATTERN"
    description: "Structural design decision"
    typical_criteria:
      - "Testability"
      - "Modularity"
      - "Performance impact"
      - "Complexity budget"
    required_fields:
      - "pattern_name"
      - "trade_offs_accepted"
      - "migration_path"

  - name: "IMPLEMENTATION_APPROACH"
    description: "How to implement a specific feature"
    typical_criteria:
      - "Effort estimate"
      - "Risk assessment"
      - "Constitution compliance"
    required_fields:
      - "approach_description"
      - "alternatives_rejected"

  - name: "PLATFORM_SUPPORT"
    description: "Platform/OS specific decisions"
    typical_criteria:
      - "Tier 1 platform compatibility"
      - "Testing feasibility"
      - "Maintenance burden"
    required_fields:
      - "platforms_affected"
      - "platform_specific_notes"

# Decision Template
# Copy this when adding a new decision
decision_template:
  id: "D000"
  title: "Decision Title"
  category: "LIBRARY_SELECTION" # One of categories above
  research_id: "R00" # Which research area produced this
  feature_ids: # Which features this affects
    - "F000"
  status: "PROPOSED" # PROPOSED | UNDER_REVIEW | APPROVED | REJECTED | IMPLEMENTED

  dates:
    proposed: null
    approved: null
    implemented: null

  context:
    problem_statement: "What problem does this solve?"
    constraints: []
    assumptions: []

  options_considered:
    - name: "Option A"
      pros: []
      cons: []
      score: null
    - name: "Option B"
      pros: []
      cons: []
      score: null

  decision:
    selection: "Option A"
    rationale: "Why this option was chosen"
    trade_offs_accepted:
      - "Trade-off 1 we accept"
    fallback_plan: "If this doesn't work, we will..."

  implementation:
    effort_estimate: "S/M/L"
    blocking_tasks: []
    non_blocking_tasks: []

  review:
    reviewers: []
    concerns_raised: []
    concerns_addressed: []

  validation:
    success_criteria: []
    validation_method: "How we'll know this was right"
    revisit_trigger: "Conditions that should trigger reconsideration"

# Actual Decisions
# Add new decisions here as research produces them
decisions:
  - id: "D001"
    title: "HTTP Client Library Selection for Go Core"
    category: "LIBRARY_SELECTION"
    research_id: "R01"
    feature_ids:
      - "F011"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-25"
      approved: null
      implemented: null

    context:
      problem_statement: "Need to select HTTP client approach for SafeDownload's Go core download engine, supporting resumable downloads via Range headers"
      constraints:
        - "Must support HTTP Range headers for resume (Constitution Principle III)"
        - "Minimal external dependencies (Constitution Principle II)"
        - "Context cancellation for clean abort"
        - "Connection pooling for concurrent downloads"
      assumptions:
        - "Performance is comparable across options with proper configuration"
        - "stdlib net/http provides sufficient primitives"
        - "Custom wrapper development effort is acceptable (2-3 days)"

    options_considered:
      - name: "stdlib net/http with custom wrapper"
        pros:
          - "Zero external dependencies"
          - "Full control over implementation"
          - "Battle-tested by millions of Go applications"
          - "Maintained by Go team"
          - "HTTP/2 automatic upgrade"
          - "First-class context cancellation"
        cons:
          - "More boilerplate code needed"
          - "Must implement progress tracking manually"
          - "Resume logic requires custom implementation"
        score: 91.5

      - name: "grab library (github.com/cavaliergopher/grab)"
        pros:
          - "Built-in resume support"
          - "Progress tracking via channels"
          - "Checksum verification included"
          - "Batch download API"
          - "Well-designed API"
        cons:
          - "Last major update 4 years ago"
          - "28 open issues"
          - "External dependency"
          - "No HTTP/2 optimizations"
        score: 71.0

      - name: "resty library (github.com/go-resty/resty)"
        pros:
          - "Actively maintained"
          - "Large community (11k+ stars)"
          - "Rich middleware ecosystem"
        cons:
          - "Not designed for file downloads"
          - "No resume support built-in"
          - "Heavy feature set we don't need"
          - "Multiple transitive dependencies"
        score: 71.5

      - name: "go-retryablehttp (github.com/hashicorp/go-retryablehttp)"
        pros:
          - "Automatic retry with backoff"
          - "Maintained by HashiCorp"
        cons:
          - "MPL-2.0 license (more restrictive)"
          - "Retries entire request, not resume"
          - "80 open issues"
          - "External dependency"
        score: 66.5

    decision:
      selection: "stdlib net/http with custom wrapper"
      rationale: |
        stdlib net/http provides all primitives needed for resumable downloads
        while maintaining zero external dependencies. This aligns perfectly with
        Constitution Principle II (minimal dependencies). The grab library
        offers excellent patterns to study and inform our wrapper design, but
        its maintenance status (4 years since major update) creates long-term risk.

        Key factors:
        1. Zero dependencies = no external project risk
        2. Full control over resume behavior implementation
        3. Can be optimized specifically for our use case
        4. Go team maintenance ensures long-term stability
      trade_offs_accepted:
        - "Additional 2-3 days development time for wrapper"
        - "Must implement and test resume logic ourselves"
        - "Progress tracking requires custom implementation"
      fallback_plan: "If custom wrapper proves problematic, can adopt grab as a reference and port specific modules"

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Create download manager wrapper with Resume support"
        - "Implement connection pooling configuration"
        - "Write comprehensive tests for Range header handling"
      non_blocking_tasks:
        - "Benchmark against grab for performance validation"
        - "Document API surface for future contributors"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "Resume correctly handles 206 Partial Content responses"
        - "Graceful degradation when Range not supported"
        - "Connection pool efficiently handles concurrent downloads"
        - "Startup time <500ms (performance gate)"
        - "Memory usage within acceptable bounds"
      validation_method: "Integration tests + benchmarks during Sprint 01"
      revisit_trigger: "If implementation takes >5 days or performance benchmarks fail gates"

  - id: "D006"
    title: "REST API Framework Selection"
    category: "LIBRARY_SELECTION"
    research_id: "R08"
    feature_ids:
      - "F025"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-28"
      approved: null
      implemented: null

    context:
      problem_statement: "Choose the Go HTTP framework for SafeDownload REST API"
      constraints:
        - "Optional component only; must not force deps on core"
        - "Permissive license"
        - "SSE integration for progress"
      assumptions:
        - "Performance differences negligible for our needs"

    options_considered:
      - name: "stdlib net/http"
        pros: ["Zero deps", "Full control", "Go team maintained"]
        cons: ["More boilerplate", "Manual middleware"]
        score: 86
      - name: "gin"
        pros:
          [
            "Active ecosystem",
            "Middleware support",
            "Good docs",
            "net/http-based",
          ]
        cons: ["Slight learning curve"]
        score: 90
      - name: "echo"
        pros: ["Minimalist", "Fast"]
        cons: ["Smaller ecosystem"]
        score: 82
      - name: "fiber"
        pros: ["Fastest benchmarks", "Express-like"]
        cons: ["fasthttp dependency", "Compatibility trade-offs"]
        score: 72

    decision:
      selection: "gin"
      rationale: "Best balance of DX, ecosystem, and net/http compatibility; aligns with constitution via optional API frontend"
      trade_offs_accepted:
        - "Framework dependency in optional component"
      fallback_plan: "Use stdlib net/http (or chi) if framework overhead becomes an issue"

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Scaffold Gin server with versioned routes"
        - "Integrate SSE endpoint for progress events"
      non_blocking_tasks:
        - "Add WebSocket endpoint if future features require bidirectional control"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "SSE stream stable under concurrent downloads"
        - "Auth middleware protects endpoints"
        - "Endpoints meet basic performance gates"
      validation_method: "Local prototype + integration tests"
      revisit_trigger: "If SSE is insufficient for client needs"

  - id: "D007"
    title: "Real-time Updates Mechanism"
    category: "ARCHITECTURE_PATTERN"
    research_id: "R08"
    feature_ids:
      - "F025"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-28"
      approved: null
      implemented: null

    context:
      problem_statement: "Select mechanism to stream progress updates to API clients"
      constraints:
        - "Proxy/firewall friendly"
        - "Low complexity"
      assumptions:
        - "One-way event streaming meets initial requirements"

    options_considered:
      - name: "Server-Sent Events (SSE)"
        pros: ["Simple", "HTTP-friendly", "Low overhead"]
        cons: ["One-way only"]
        score: 90
      - name: "WebSocket"
        pros: ["Bidirectional", "Rich interactions"]
        cons: ["More complex", "Potential proxy issues"]
        score: 78

    decision:
      selection: "SSE now; WebSocket optional later"
      rationale: "SSE aligns with needs and keeps complexity low; WebSocket added only when truly needed"
      trade_offs_accepted:
        - "No client-to-server messaging over SSE"
      fallback_plan: "Introduce WebSocket endpoint for interactive features if required"

    implementation:
      effort_estimate: "S"
      blocking_tasks:
        - "Implement `/api/v1/events` SSE endpoint"
      non_blocking_tasks:
        - "Add WebSocket if future feature demands"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "SSE works behind common proxies"
        - "Clients can consume progress reliably"
      validation_method: "Manual + automated integration tests"
      revisit_trigger: "Interactive control requirements emerge"

  - id: "D004"
    title: "Accessible Terminal UI Implementation Approach"
    category: "IMPLEMENTATION_APPROACH"
    research_id: "R04"
    feature_ids:
      - "F008"
      - "F014"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-26"
      approved: null
      implemented: null

    context:
      problem_statement: "Need to implement accessible terminal UI that works with screen readers, respects color preferences, and supports colorblind users while maintaining visual appeal"
      constraints:
        - "Must respect NO_COLOR environment variable (Constitution Principle XI)"
        - "Screen readers work through terminal emulators, not apps directly"
        - "WCAG 2.1 AA compliance required (4.5:1 contrast ratio)"
        - "Cannot require specific terminal emulator"
      assumptions:
        - "Users with screen readers prefer GNOME Terminal, iTerm2, or Windows Terminal"
        - "VoiceOver and NVDA are the primary screen readers to support"
        - "Emoji + text pattern provides both visual and semantic information"

    options_considered:
      - name: "Full screen reader optimization with live regions"
        pros:
          - "Best possible screen reader experience"
          - "Real-time progress announcements"
        cons:
          - "Terminal emulators don't support ARIA live regions"
          - "Implementation complexity very high"
          - "Inconsistent across terminals"
        score: 35

      - name: "Static text output with --plain flag"
        pros:
          - "Works with all screen readers"
          - "Simple implementation"
          - "Predictable behavior"
        cons:
          - "Less visually appealing"
          - "No progress animations"
        score: 75

      - name: "Layered approach: TUI default + --plain flag + NO_COLOR"
        pros:
          - "Best experience for each user type"
          - "Constitution compliant (Principle XII)"
          - "termenv library handles detection"
          - "Graceful degradation built-in"
        cons:
          - "Must maintain two output modes"
          - "Testing complexity increased"
        score: 92

    decision:
      selection: "Layered approach with TUI default, --plain flag, and NO_COLOR support"
      rationale: |
        The layered approach provides the best experience for all users:
        1. TUI mode: Rich visuals with ANSI 16-color palette for most users
        2. --plain flag: Screen reader users get linear, predictable output
        3. NO_COLOR: Automatic detection disables all styling

        Research confirmed that screen readers interact with terminal emulators,
        not applications directly. The emoji + text pattern (✅ Success, ⚠️ Warning)
        provides semantic meaning regardless of emoji rendering support.

        The termenv library (★1600, actively maintained) provides reliable
        terminal capability detection for Go implementation.
      trade_offs_accepted:
        - "Must maintain two output code paths (TUI and plain)"
        - "Cannot provide animated progress to screen reader users"
        - "Testing requires manual verification with actual screen readers"
      fallback_plan: "If termenv proves problematic, can implement simplified detection using TERM and COLORTERM environment variables"

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Implement --plain flag in CLI contract"
        - "Add NO_COLOR and SAFEDOWNLOAD_PLAIN environment variable detection"
        - "Create ANSI 16-color palette with WCAG AA compliance"
        - "Implement linear output mode for screen readers"
      non_blocking_tasks:
        - "Add high-contrast theme as additional option"
        - "Document accessibility features in user guide"
        - "Create colorblind simulation testing workflow"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "--plain flag produces fully linear output"
        - "NO_COLOR environment variable disables all ANSI codes"
        - "Color palette passes WCAG 2.1 AA (4.5:1 contrast)"
        - "VoiceOver can read all --plain output correctly"
        - "Status indicators use emoji + text (not color alone)"
      validation_method: "Manual testing with VoiceOver on macOS, colorblind simulation tools"
      revisit_trigger: "If Bubble Tea library has better accessibility primitives in future versions"

  - id: "D005"
    title: "Distribution Tooling and Hosting Strategy for v1.3.0"
    category: "IMPLEMENTATION_APPROACH"
    research_id: "R07"
    feature_ids:
      - "F021"
      - "F022"
      - "F023"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-28"
      approved: null
      implemented: null

    context:
      problem_statement: "Select packaging tooling and distribution channels for SafeDownload v1.3.0 across macOS and Linux (Debian/Ubuntu, RPM-based)."
      constraints:
        - "Minimal maintenance burden for initial release"
        - "Signed packages and checksums for security"
        - "CI-friendly automation"
      assumptions:
        - "User base initially comfortable installing via GitHub Releases"
        - "Homebrew tap improves macOS experience significantly"
        - "Hosted repos can be added later if demand grows"

    options_considered:
      - name: "Goreleaser + nfpm; GitHub Releases + Brew tap"
        pros:
          - "Unified config and automation"
          - "Signed packages via nfpm"
          - "Tap publishing built-in"
          - "Low maintenance to start"
        cons:
          - ".deb/.rpm installed manually (dpkg/rpm) initially"
        score: 88

      - name: "Self-hosted apt/yum repos (reprepro/createrepo) now"
        pros:
          - "Best UX for Linux users"
          - "System updates integrate automatically"
        cons:
          - "High maintenance and infra complexity"
          - "Signing and rotation overhead"
        score: 68

      - name: "Hosted repo provider (Cloudsmith/PackageCloud)"
        pros:
          - "Professional hosting, lower infra burden"
          - "Good UX for users"
        cons:
          - "Ongoing cost"
          - "Vendor dependency"
        score: 78

    decision:
      selection: "Goreleaser + nfpm; GitHub Releases + Brew tap initially"
      rationale: |
        This approach delivers signed packages and a great macOS experience
        with minimal maintenance. It aligns with our constitution's minimal
        dependencies and allows us to iterate. We can add hosted repos later
        based on demand without retooling packaging.
      trade_offs_accepted:
        - "Linux users initially install via dpkg/rpm rather than apt/yum repos"
        - "Delayed repository index hosting until demand justifies"
      fallback_plan: "Adopt hosted repository provider if manual installation creates friction or support burden."

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Create tap repo and goreleaser brews config"
        - "Add nfpm sections for deb/rpm with signing via CI secrets"
        - "Publish signed SHA256SUMS with releases"
      non_blocking_tasks:
        - "Explore hosted repo options and costs"
        - "Design self-hosted repo scripts (reprepro/createrepo)"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "Brew install works from tap"
        - ".deb/.rpm install succeeds on Tier 1 platforms"
        - "Packages are signed and verifiable"
      validation_method: "Manual install tests in CI matrix + local verification"
      revisit_trigger: "Significant user demand for apt/yum repos or support friction with manual installs"

  - id: "D008"
    title: "Plugin Architecture Selection"
    category: "ARCHITECTURE_PATTERN"
    research_id: "R09"
    feature_ids:
      - "F020"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-28"
      approved: null
      implemented: null

    context:
      problem_statement: "Select runtime plugin architecture for SafeDownload"
      constraints:
        - "Cross-platform support (Tier 1)"
        - "Security isolation for third-party plugins"
        - "Minimal forced dependencies"
      assumptions:
        - "Plugins primarily extend CLI commands and processing"

    options_considered:
      - name: "Go native plugins"
        pros: ["Fast", "Type-safe"]
        cons: ["Version coupling", "Limited platform support"]
        score: 60
      - name: "Subprocess/exec + JSON-RPC over stdio"
        pros: ["Isolation", "Language-agnostic", "Simple transport"]
        cons: ["IPC overhead", "Protocol effort"]
        score: 88
      - name: "HashiCorp go-plugin (gRPC)"
        pros: ["Battle-tested", "Structured RPC"]
        cons: ["Dependency and complexity"]
        score: 85
      - name: "WASM"
        pros: ["Sandboxed", "Portable"]
        cons: ["Complex", "Perf trade-offs"]
        score: 70

    decision:
      selection: "Subprocess/exec + JSON-RPC over stdio"
      rationale: "Balances portability, security, and minimal dependencies while maintaining optional plugin model."
      trade_offs_accepted:
        - "Design and maintain a small RPC protocol"
        - "Slight performance overhead vs in-process"
      fallback_plan: "Adopt HashiCorp go-plugin if richer RPC features needed"

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Define JSON-RPC schema and host interface"
        - "Implement plugin discovery and manifest"
        - "Create sample plugin (Go and Python)"
      non_blocking_tasks:
        - "Optional sandboxing integrations (seccomp/macOS sandbox)"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "Plugins run cross-platform (macOS, Ubuntu, Debian)"
        - "Host enforces env/args allowlist"
        - "Protocol supports capability discovery and version negotiation"
      validation_method: "Integration tests with sample plugins"
      revisit_trigger: "If protocol complexity grows beyond scope"

# Decision Backlog
# Decisions that need to be made but lack sufficient research
backlog:
  - id: "DB001"
    question: "HTTP client library selection (grab vs stdlib)"
    research_id: "R01"
    blocking_version: "1.0.0"
    urgency: "HIGH"
    notes: "Foundational decision for Go core"

  - id: "DB002"
    question: "Bubble Tea component library vs custom components"
    research_id: "R02"
    blocking_version: "1.1.0"
    urgency: "HIGH"
    notes: "Affects TUI development velocity"

  - id: "DB003"
    question: "Rate limiting algorithm selection"
    research_id: "R03"
    blocking_version: "1.2.0"
    urgency: "MEDIUM"
    notes: null

  - id: "DB004"
    question: "Screen reader testing approach"
    research_id: "R04"
    blocking_version: "1.1.0"
    urgency: "HIGH"
    notes: "RESOLVED - See decision D004"

  - id: "DB005"
    question: "State migration strategy (manual vs automated)"
    research_id: "R05"
    blocking_version: "1.0.0"
    urgency: "HIGH"
    notes: "Affects data safety guarantees"

  - id: "DB006"
    question: "GPG verification approach (pure Go vs subprocess)"
    research_id: "R06"
    blocking_version: "1.2.0"
    urgency: "LOW"
    notes: null

  - id: "DB007"
    question: "Package repository hosting (self-hosted vs GitHub only)"
    research_id: "R07"
    blocking_version: "1.3.0"
    urgency: "LOW"
    notes: "RESOLVED - See decision D005"

  - id: "DB008"
    question: "REST API framework selection"
    research_id: "R08"
    blocking_version: "2.0.0"
    urgency: "LOW"
    notes: "RESOLVED - See decision D006"

  - id: "DB009"
    question: "Plugin system architecture"
    research_id: "R09"
    blocking_version: "1.2.0"
    urgency: "MEDIUM"
    notes: "RESOLVED - See decision D008"

  - id: "DB010"
    question: "CGO usage policy"
    research_id: "R10"
    blocking_version: "1.0.0"
    urgency: "HIGH"
    notes: "Affects entire build system"

# Expedited Decision Process
# For time-sensitive decisions that can't wait for full research
expedited_process:
  criteria_for_expedited:
    - "Blocking critical path for current sprint"
    - "Security vulnerability requiring immediate mitigation"
    - "External dependency EOL or critical bug"

  expedited_steps:
    - step: 1
      action: "Document decision need with justification"
      duration: "1 hour"

    - step: 2
      action: "Quick evaluation of top 2-3 options only"
      duration: "2-4 hours"

    - step: 3
      action: "Make provisional decision with explicit revisit date"
      duration: "Immediate"

    - step: 4
      action: "Create backlog item for full research validation"
      duration: "5 minutes"

  provisional_decision_template:
    id: "PD000"
    title: "Provisional: Decision Title"
    status: "PROVISIONAL"
    revisit_date: "YYYY-MM-DD"
    validation_research: "R00" # Research that will validate/revise this
    notes: "Made expedited because..."
